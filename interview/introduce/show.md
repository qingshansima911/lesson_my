# 展示点 啊哈时刻
- cookie session
  - cookie前端后端都能种 Cookie数据存储在用户的浏览器（危险）4KB  
  - session只在后端，是内存对象 Session数据存储在服务器上（安全）5MB  
  session_id uid sid -> session找回来我们的用户JSON KV 查找   
  auth / session 中间件 ctx.user = ctx.session  

- cookie 或者本地存储
  - httpOnly true 只在http请求过程中传输 默认是js也可以读取
    XSS攻击的原理：通过在网页中植入一段js代码，把cookie读取，发送到黑客，获取了身份，比如session_id这种cookie一定要设置为true，一些username等js需要访问，安全性没问题的业务cookie不设置
  - secure    
    https 可靠连接才会发送

- 本地存储
  - 有效时间
    cookie 可以设置过期时间，每次请求都会传输，要考虑性能和安全问题   
    localStorage 一直都在，不会传输 只存在客户端，默认不参与与服务端的通信  
    sessionStorage 关闭就没有  只存在客户端
  - 存储大小
    cookie最小4KB  
    localStorage sessionStorage 5MB
    IndexedDB 数据库 更大 

- 同源策略
  - 沙箱
  - 跨域

- 状态码
  301表示永久重定向，客户端应该使用新的URL  
  302表示临时重定向，客户端应该使用新的URL    
  307表示临时重定向，但要求客户端保持请求方法一致  302的缺点是重定向后的方法会变成get  

- 从url输入到页面显示的具体过程
  1. 用户输入url并回车
  2. 浏览器进程检查url，组装协议，构成完整的url，服务器返回https://www.baidu.com 307 
  3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
  4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
  5. 如果没有，网络进程向web服务器发起http请求   
    5.1 进行DNS解析，获取服务器ip地址，端口
    5.2 利用ip地址和服务器建立tcp连接
    5.3 构建请求头信息
    5.4 发送请求头信息  
    5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容 
  6. 网络进程解析响应流程
    6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步，如果是200，则继续处理请求。  
    6.2 200响应处理： 
      检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行  
      后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。   
  7. 准备渲染进程  
      7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程   
  8. 传输数据、更新状态  
    8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”  
    8.2 渲染进程接收完数据后，向浏览器发送“确认提交”  
    8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。  

- chrome浏览器
  浏览器进程、GPUG进程、网络进程、渲染进程、插件进程
  - 浏览器进程
    主要负责界面显示、用户交互、子进程tab管理、存储，还负责创建和管理其他进程，如网络进程、渲染进程、插件进程等
  - 渲染进程(多个)
    将html、css、js转换为用户可以与之交互的网页，排版引擎blink和js引擎V8都运行在该进程中，chrome会为每个tab标签都创建一个渲染进程，渲染进程运行在沙箱模式下
  - GPU图形处理器进程
    将渲染后的图像传递给浏览器进程进行显示
  - 网络进程
  - 插件进程
  - 下载进程
  - 进程间通信（IPC）
    这些进程之间通过进程间通信（IPC）来进行交互和数据传输。
  - 浏览器缓存
    本地缓存
    - 强缓存
  - 网络通信
    - dns查询 获得ip地址
      缓存
    - 三次握手 建立TCP连接
    - 构建请求信息
      status code  content-type 
      - 301/302 + Location url 跳转请求 307  
      - 200 
      请求行 method url http 协议版本  
      请求头 cookie authorization  
      请求行  
    - 发送请求信息
    - 服务器响应后，网络进程接受请求头和请求体，并生成响应内容  
      - 响应头
      - 响应体
      - 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染
        content-type 二进制流
        img 
        css 
        html
    - 四次挥手结束请求
      如果，浏览器或者服务器在HTTP头部加上Connection:Keep-Alive ，TCP就一直保持连接。  
      http 1.1/2.0 Keep alive 多路复用  
      1.0 keep alive  
      1.1 管道 顺序  
      2.0 多路复用 数据帧 唯一id  
    - 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 loading
    - 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页
    - 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来

- DOM树的构建过程
  - 二进制根据字符集编程html格式文本 text/html;charset=utf-8  
  - 分词
  - 节点
  - 树状结构组织 DOM树  
- CSSOM树构建过程
  二进制 -> css文本 -> 分词 -> 样式节点 -> CSSOM树  
- 渲染树
  根据DOM树和CSSOM树生成render tree  
- 渲染
  1. 计算CSS样式
  2. 构建渲染树
  3. 布局
  4. 绘制
- 布局layout导致重排，重绘即css样式属性发生了变化 


- 强缓存和弱缓存
  强缓存：
    Cache-Control
      public：允许任何缓存（如浏览器缓存、CDN 缓存）进行缓存。
      private：仅允许客户端（浏览器）进行缓存。
    Expires 设置缓存的过期时间
  弱缓存：
    ETag
      客户端在下一次请求时可以将该标识符发送给服务器，服务器可使If-None-Match字段进行比对，若资源未改变，则返回 304 Not Modified 状态码。
    Last-Modified 最后修改时间
      客户端在下一次请求时可以将该时间发送给服务器，服务器可使用 If-Modified-Since字段进行比对，若资源未修改，则返回 304 Not Modified 状态码。

